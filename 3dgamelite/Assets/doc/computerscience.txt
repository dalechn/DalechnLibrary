
// 不满足交换律 a * b != b * a (未知:好像有特殊情况?)
// 结合律 a * b * c = a * (b * c), a*(A*B) = a*A*B (a为数)
// 分配律 a * (b+c) = a * b+a * c

// 行列式(determinant) 列(column),行(row)      符号:det(A)或 |A|
// 单位矩阵(E identity matrix)                          符号:E
// 伴随/共轭矩阵( adjoint matrix) 未知?            符号:A*
// 增广矩阵(augmented matrix) 未知?
// 矩阵的秩( rank) 未知?                                  符号:r(A)
// 矩阵的乘法需要左边的矩阵的列向量dot右边的矩阵的行向量,得出的矩阵为左边的矩阵行数+右边矩阵的列数(M*N)*(N*P) = M*P
// 矩阵的逆( inverse) 为倒数运算                      符号:A-¹      A*A-¹ = E     (A*B)-¹  = A-¹ * B-¹
// 矩阵的转置(transpose)为行列互换运算          符号At        (A*B)t = At*Bt
// 转置矩阵和逆矩阵相等的矩阵就被称作正交矩阵(orthogonal matrix)
// a·b = At * B  a的转置矩阵 * b的矩阵
// axb = A* * B  a的对偶矩阵(dual matrix)* b的矩阵 未知?

// 仿射变换(affine transformation) = 线性变换(一个矩阵*一个坐标)+平移变换: 平移(Translation),旋转(Rotation),缩放(Scaling),剪切(Shearing),对称(Mirroring):原点,x,y,z对称,反射(Reflection)
// 齐次坐标系(homogeneous coordinates)
// 笛卡尔坐标系(cartesian coordinates)


//游戏流程:
// 1--------------------------cpu(和内存(RAM),硬盘(HDD,SSD)交互): 
// 内存区域:堆(Memory Heap),栈(Call Stack),静态区域(static),常量区域(const readonly)
// 成员变量(member variable)(不需要初始化),局部变量(local variable)(需要初始化),函数/方法地址(function)
//文件名/其他:FileTest,file_test
//包名：com.deamerstudio.xxxtest
//类名/结构体,接口名,枚举：CSharpTest/SStruct,IInterfaceTest,EEnumTest(ENUMVALUE,ENUM_VALUE)
//函数名: DataTest,dataTest
//变量名：memberTest (属性:MemberTest)(字段:memberTest,m_MemberTest,_memberTest)
//常量名：CONST_TEST,k_CONST_TEST
//静态名: Instance, s_Instance

//// (c++ 值/指针传递(pass by value/pointer),引用传递(pass by reference))编译型语言(compiled language);
// (c#值/指针传递,引用传递)编译型语言(interpreted languages)
// js,lua,phthon 脚本语言(script language)

// 2--------------------------cpu和显存交互, gpu(和显存交互)(猜测:dx做的事?): //未知点:不确定是否在这个阶段发送数据也就是发送drawcall?
// Input Assembler(IA) 输入装配阶段 --√  
//  
// Unity自定义流水数据,写入常量缓冲区: 灯光颜色,灯光位置,环境光颜色,自定义颜色,相机位置, MVP矩阵,
// Unity固定流水数据,写入顶点,索引缓冲区: 顶点,法线,切线,纹理坐标,


// 3--------------------------//cpu和显存交互, gpu(和显存交互): // 未知点: 图元(primitives)?
// 1------------------ Vertex Shader(VS) 顶点着色阶段 --√
// 已知可以:计算裁剪空间坐标(MVP矩阵),计算模型世界坐标法线,传递uv坐标


// 2-------------------中间其他阶段----------------------------------


// 3------------------Rasterizer(RS) 光栅化阶段 --√
// 把顶点数据转换为片元(fragments) 已知:采样(sampling),反走样 (anti-aliasing)(抗锯齿(anti-jaggies)处理)


// 4------------------Pixel Shader(PS) 像素着色器阶段 --√
// 已知可以: 通过 灯光颜色,灯光位置,环境光颜色,自定义颜色,相机位置计算灯光颜色, 通过法线, 视线计算颜色

//=> Pixel OwnerShip Test(像素所有者测试)=> Scissor Test (裁剪测试)=>Alpha Test(clip函数) => Stencil Test => Depth Test =>Blending => Dithering(抖动) =>Logic Op
//=>GBuffer=>front buffer=>frame buffer		//不知道是不是这个阶段进行的

// 5------------------Output Merger(OM) 输出合并阶段 --√ //不确定干啥的?


//mvp矩阵
//(模型/物体/本地坐标系)local/model/space ->(model matrix(unity_ObjectToWorld模型变换)), transform的trs矩阵 == >
                                                                                    //未知:css还未确定?
//	(世界坐标系)world space(dx左手, opengl右手, unity左手,css左手) ->(view matrix(unity_MatrixV视点变换)), camera的transform的trs矩阵 == >

//	(眼坐标系)view space->(perspective / orthographic projection matrix(glstate_matrix_projection投影变换投影变换)), camera的project矩阵 == >

//	(归一化坐标系 normalized device coordinates)ndc space -> (齐次裁剪坐标系)homogeneous clip space  ->(viewport transform视口变换) == >

//	(屏幕坐标系)screen space(dx左上角原点(0,1), opengl左下角原点(-1,1), unity左下角原点(0,1),css(左上角原点(0,1)))
//
// uv坐标: opengl( opengl左下角原点(0,1),dx左上角原点(0,1),unity左下角原点(0,1),)
//	惯性坐标系:不旋转的本地坐标系
//	aspect ratio : 宽高比
//


//Point:需要构造(x,y,z,1)(只要w分量!=0就可以表示点)
//Vector:需要构造(x,y,z,0)
//旋转矩阵(矩阵的乘法)(右手坐标系):     // 逆矩阵: 旋转矩阵是一个正交矩阵,所以求转置矩阵就行
// 绕x轴矩阵(yz平面):  //pitch,gradient                                                 
//x′=x                      | 1,0,     0,     0 |  |x|
//y′=ycosθ−zsinθ            | 0,cosθ,-sinθ,   0 | *|y|
//z′=ysinθ+zcosθ            | 0,sinθ, cosθ,   0 |  |z|
//                          | 0,0,     0,     1 | |1|

// 绕z轴矩阵(xy平面):    //roll,banking                                               
//x′=ysinθ+zcosθ            | cosθ,-sinθ, 0,0 |   |x|
//y′=ycosθ−zsinθ            | sinθ, cosθ,0,0  | * |y|                   //未知: 旋转矩阵还需要更多推导?
//z′=z                      | 0,0,     1,    0|   |z|
//                          | 0,0,     0,   1 |   |1|

// 绕y轴矩阵(xz平面):   // yaw,turn, heading                                           
//x′=zsinθ+xcosθ            | cosθ,0, sinθ,  0 |  |x|
//y′=y                      | 0,    1,0     ,0 | *|y|
//z′=zcosθ−xsinθ            | -sinθ, 0,cosθ, 0 |  |z|
//                          | 0,0,     0,    1 |  |1|

//最终的顶点*旋转矩阵: E(α,π/2,β) = Rz(β) * Ry(π/2) * Rx(α) =  Ryz(α) *Rzx(π/2)* Rxy(β) = Ry(π/2) * Rx(α-β) 


//// quaternion顶点*轴角:  3d空间中任意一个v沿着单位向量u旋转θ角度之后的v'为:  v' = cos(θ)*v + (1-cos(θ))*(u.v).u + sin(θ)*(uxv)
///
/// 赋值给transform的rotation(Quat=Quat), 
/// 对已有Vec3变换(Quat*Vec3), 
/// 运算Quat*Quat 
///

//平移矩阵(矩阵的加法):                      // 逆矩阵(矩阵的减法): 
//x'    | 1,0,0,dx| |x|       |x+dx|              | 0,0,0,-dx| |x|       |x-dx|   
//y'    | 0,1,0,dy|*|y| =   |y+dy|              | 0,0,0,-dy|*|y| =   |y-dy|
//z'    | 0,0,1,dz|  |z|       |z+dz|              | 0,0,0,-dz|  |z|       |z-dz|
//      | 0,0,0,1  |  |1|       |1|                   | 0,0,0,1  |  |1|       |1|

//缩放矩阵(矩阵的乘法)                       //逆矩阵:
//x'    | sx,0,0,0| |x|                               | 1/sx,0,0,0| |x|   
//y'    | 0,sy,0,0|*|y|                               | 0,1/sy,0,0|*|y| 
//z'    | 0,0,sz,0|  |z|                               | 0,0,1/sz,0|  |z|  
//      | 0,0,0,1  |  |1|                              | 0,0,0,   1  |  |1|   

//正交投影矩阵:


//透视投影矩阵:
